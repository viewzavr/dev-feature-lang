# Пакет нововведений декабрь 2022

F-CO23 F-JS-INLINE

# Императивное вычисление

## Мотивация

Предыдущий вариант с m-lambda приводит к громоздким конструкциям, т.к. аргументы перечисляются и в сигнатуре js-кода, и по сути дублируются в позиционных аргументах. 

Пример:
```
button "Удалить" 
  on_click=(m-func "(obj) => {
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  }" @co->input?)
```

Нововведения по вычислениям в этом документе дают следующий, более лаконичный код:
```
button "Удалить" 
  on_click={: obj=@co->input? |
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  :}
```

## Императивное вычисление

Форма `{: привязки-и-позиционые-аргументы | js-код :}` порождает функцию с привязками к контексту компаланга. Затем эту функцию можно вызывать из яваскрипта или с помощью eval.

Формат привязки: `a b=@some c=(compalang-expression) d=555 e f`.
Здесь `a,e,f` значит позиционые аргументы функции, а `b,c,d` - значения привязанные к окружению и константы.

Примеры:
```
let a = 5 b = 7
let f = {: a=@a q=(@a + @b) p=44 k | return [a+q+p,k] }

console-log "result = " (m-eval @f) // вызов без передачи аргументов
console-log "result = " (m-eval @f 10) // вызов с передачей позиционных аргументов

console-log "simple result =" (m-eval {: 5+10 :}) // простое вычисление без привязок и без return
console-log "xtra result=" (m-eval {: f=@f | f.apply( this, 10 ) }) // передача функции как аргумента и её вызов из js
```

# Реакции

Необходимо реагировать на события. Реакция это у нас формально - некое развитие процесса. Она может быть описана декларативно (на компаланге) или императивно. При этом декларативность, формально, может означать как дополнение процесса некоторыми подпроцессами, так и некоторое процессное вычисление, которое в конце концов заканчивается и сворачивается. Кроме того, у нас не поддерживается пока переход в "управляющие состояния", но возможно это и не надо, а возможно выражается декларативно/императивно, а возможно это можно поддержать в будущем.

Ранее у нас уже сделан ряд "обычных" реакций (on, c-on, cc-on) и реакций в режиме "массовых модификаторов": `@objlist | x-modify { x-on "func" }`. Их стало очень много, и надо сделать что-то одно. `on` - работали с событиями объектов вьюзавр. c-on и cc-on работали с каналами. В принципе, cc-on это почти то что надо, и мы его здесь зафиксируем с новым именем `reaction`.

Для массовых реакций - пока неясно что делать.

# reaction

1. Базовая форма
```
reaction @channel @func
```
- вызывает func при каждой записи в channel. Передает аргумент - значение, которое записали в channel.

Пример:

```
d: div
reaction (dom-event @d "mousemove") {: evt | console.log( evt.clientX) :}
```


2. Поддержка {}-функций
```
reaction @channel { |value|
	...compalang-code...
}
```
создается процесс, описанный compalang-code. Он завершается, когда в коде сработает оператор `return @some-value`.
(но в целом это все пока неясно очень все). По сути, это адаптер к make-func.

3. Поддержка input
```
@channel | reaction @func
@channel | reaction { |val|
  console-log "hello" @val | return
}
...
```
В этом варианте reaction.. может возвращать что-то полезное, например исходный канал.

Примечание: поддержку нескольких каналов в стиле `reaction @channels-list @func` решено пока не делать. Вместо неё race-channels @list и т.п.

## Получение каналов
Для работы реакций нужны каналы. В синтаксисе компаланг они недоступны. Предлагаются такие методы:
```
event @obj "name" -- возвращает канал, соответствующий событию name объекта @obj. Когда в объекте срабатывает событие, производится запись в канал. Если запись в канал производится извне, то в объекте срабатывает событие.
dom-event @obj "name" -- возвращает канал, соответствующий dom-событию name объекта @obj, который является dom-элементом.
param-changed @obj "param-name" - возвращает канал, связанный с параметром param-name. Запись в канал производится, когда значение параметра меняется. Запись в канал извне приводит к установке параметра.
param-assigned @obj "param-name" - возвращает канал, связанный с параметром param-name. Запись в канал производится, когда значение параметра присваивается (пусть даже). Запись в канал извне приводит к установке параметра. 
method-channel @obj "name" - запись в такой канал приводит к вызову метода (привязанной функции) у obj.ы
```
Соображения:
1. event и dom-event - хорошо вроде.
2. param-changed и param-assigned - вроде можно соединить в одно, и управлять выбором changed/assigned через параметр,
например: `param @obj "name" only_changes=true`
3. Вопрос как назыввать это (2)? param? Но это слово (param) хотелось бы оставить для чего-то мб другого. Тогда param-channel? Но почему не param-channel? Но почему channel, почему это не cell?

По повову (3) есть еще отдельный ряд мыслей - это все-таки у нас каналы (channel) или ячейки (cell)?
Вероятно это каналы. А ячейки.. это могут быть вообще отдельные объекты. Т.е.:
```
  x: create-channel @alfa // на выходе канал для чтения и записи значений. параметр value также связан с каналом
  y: @alfa | create-channel
  z: param @obj "paramname"
  reaction @x.output "|arg| console.log(arg)"
```
В общем эта часть еще есть большое todo.

# Создание объектов.
Текущая проблема компаланга в том что у него очень много методов создания объектов. Надо их сократить, до 1-2.
Потребности:
1. создать набор объектов согласно списку описаний объектов
Пример: ` read @objects-list | create target=@target-obj`
При этом надо уметь получить результат - список созданных объектов.
2. создать набор объектов согласно списку значений и описанию объекта.
Пример: ` repeater model=[1,2,3] { |input| rectangle width=@input } `
3. создать набор объектов согласно списку описаний объектов, и передать им значения в качестве позиционных аргументов:
Пример 1: `computing-env @arg1 @arg2 { |arg1 arg2| ...compalang... }`
Пример 2: `computing-env @arg1 @arg2 code=@some-code`
Если значения аргументов arg1 arg2 меняются, их следует передать в созданное окружение.
При этом, в случае конкретно computing-env, результатом является не список созданных объектов, а значение параметра output.
Вероятно, этот computing-env можно как-то было бы выразить через create (если бы тот умел передавать аргументы).

Примечания. Иногда в (1) требуется создавать объекты не в 1 целевом объекте @target-obj в наборе объектов. Но вероятно этого же можно достичь и используя repeater, т.е. `repeater { |target-obj| create input=@list target=@target-obj }`.

4. Создавать пустой объект 1 штуку. Это надо уметь, чтобы конструировать объекты с помощью компаланга динамически и описывать это на самом компаланге. Кроме этого, понадобится умение применять к объекту фичу, устанавливать параметры.
Это могло бы выглядеть так:
```
  let x = (create-object "button")
  let y = (create-object)
  apply-feature @y "buttons"
```
Также были мысли, что в качестве фичи может выступать и функция. Т.е. по сути это применение функции к объекту:
```
  apply-feature @obj (n-eval "|env| env.setParam('output',22) ")
```
В целом кстати последний вариант, с функцией, он честнее. Потому что фичи, похоже, это все-таки не часть объекта, не его "тип", а что-то отдельное, тоже кстати возможно объектное (если имеет параметры, которые могут меняться во времени). Но это история для отдельного размышления.

5. Создавать объекты не в пространстве детей, а в пространстве "внедренных-фич". Т.е. уметь динамически выполнять то, что у нас записывается сейчас как object {{ attached-feature @arg }}.

## Предложение.
Выразить все потребности перечисленные выше с помощью методов `create` и `repeater`.

## create
create - создаёт набор объектов, передает им позиционные параметры. Примеры:
```
 create input=@objects-list target=@parent
 create input=@objects-list target=@parent @value1 @value2
 create target=@parent @value1 @value2 { |a1 a2|
 	... compalang-code ....
 }
```

## repeater
repeater - остается без изменений как уже есть сейчас. Репитер создает указанный объект N раз. N определяется массивом model, значения этого массива передаются через scope. Примеры:
```
 repeater model=@some-list code=@object-code
 repeater model=@some-list { |arg|
 	 console.log @arg
 }
```
Примечания. 
* Сейчас репитер на вход получает описание 1 объекта. Формально, он бы мог получать описание многих объектов - по идее, ему без разницы, при наличии scope, сколько объектов создавать в ответ на одну запись в model.
* Вероятно, репитер можно совместить с create, т.е. наделить create поведением репитера. Тогда:
```
  create model=@some-list code=@objects-list
```
создаст @objects-list объекты столько раз, сколько записей в some-list. Но это кажется является усложнением. Кроме того, они отлично компонуются, `repeater { create ... }`.

# Продолжение вычислений

Появилась идея (Михаил) такая что:
```
object a={: 5+5 :} // это функция
       b=({: 5+5 :}) // это вычисление
       c=({: a b | a+b :} 5 5) // вычисление с позиционными аргументами
       d=({: a | a+b :} 5 b=5) // вычисление с позиционными и именованными аргументами
```
Таким образом, с т.з. синтаксиса возникает следующая особая форма:
* ({: функциональное-выражение :} параметры...)
здесь скобки () обязательны, без них это выражение спутается с просто указанием аргументов другим объектам.
в целом скобки () в компаланг означают "вычислить подвыражение" и поэтому это приемлемо и нормально.

Как индукция, видимо из этого следует такая возможность:
```
let foo={: a | a + b :}
foo b=4
```
то есть поиск "типов" объектов ("фич") проводится в scope. И если найденное значение есть "функция", то автоматически порождается eval. Можно ввести для этого и особую форму, чтобы было проще в реализации:
```
func foo {: a | a + b :}
```

Вопросы остаются:
* о доступе изнутри js-кода к функциям, обозначенным в компланг-модуле:
```
func foo {: a | a + b :}
func foo2 {: a | a + foo(a,b) :}

foo2 5 10
```
* о значениях позиционных аргументов по умолчанию. Использовать синтаксис a=xxx как выше не получится, т.к. это означает просто привязку и такой аргумент пропускается:
```
func foo {: a b=12 : a + b :}
foo2 5 10 
```
Здесь 10 не пройдет, и будет 12 -- т.к. по логике в начале документа это привязка (binding) к окружению и такой параметр (b=..) не учтется в списке позиционных аргументов.