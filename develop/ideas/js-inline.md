F-JS-INLINE

По аналогии с Lingua Franca но по-другому: ввести [[[ xxx ]]]
где xxx это js код который выполняется на этапе компиляции компаланг-кода.

Тогда:
object a=[[[ Math.sin(10) ]]] b = (m-lambda [[[ (a) => a+1 ]]] @teta.value)
  on-click=[[[ () => console.log("clicked") ]]]

почему [[[ ]]] потому что
а) в js иногда встречается ]] но редко ]]]
хотя мб там не будет открывыющихся скобочек и все будет норм.
можно и с [[ попробвоать ]]
б) подсветка синтаксиса в sublime внутри работает хорошо
в) в сублиме ставим откр скобочки [[ и сразу делает закрывающиеся - удобно ]]

в ЛФ идет {= yyy =} но там
а) сублиме не ставит автоматом =}
б) это у них строчки а не js. строчка это удобно конечно, т.к. позволяет генерить функции
вне синтаксиса x,y => .... типа напрямую обращаясь из js. Но в ЛФ идет сигнатура метода
и явно и кратко указываются "порты" (типа reaction x s.y {=  console.log(x, s.y) =})
т..е у них такая более безшовная интеграция что-ли. но у нас она вроде не прокатит,
т.к. cc-on (some-channel 123)
но можно и подумать, например потребовать чтобы cc-on образовывался только ссылками
(что будет странно)

остаются конечно сомнения, тк..
on-click=[[ () => console.log("clicked") ]]
выглядит много кода.. хотя бы
on-click=[[ console.log("clicked") ]]
но нужны аргументы.. и надо отличать от непосредственной формы..
и да, надо аргументы уметь перечислить явно...
ну и еще вариант можно так ввести свою форму записи аргументов:

on-click=[[ |event| console.log("clicked") ]]
либо
on-click=[[ event ==> 
  let a = 5;
  console.log("clicked",a) 
  ]]

---
и на дальнейшее - подумать об императивных генераторах строчек. который мб поддержать синтаксически
т.е. внедрить какой-то императивный код и тогда:

x: rectangle {
  erb "<% for i in (1..#{@x.k}) do %>
    circle
    <% end %>" | compalang | create-objects
}

а с синтаксич поддержкой:

x: rectangle {
	(((
	<% for i in (1..#{@x.k}) do %>
    circle
    <% end %>
	)))
}

------
--
пробую - и выходит что нельзя ]] делать т.к. там признак идет - парсим все вплоть до этого символа.
т.е. мы не js парсим а символы.
преимущество в том, что - когда js поменяется нам не надо переделывать парсер.
плюс js парсить непросто, сложнее чем компаланг. да и от языка не хотелось бы зависеть.

но кстати:
1 таки ]] можно но если открывается с [[. а если с трех [[[ то и закрывать ]]].
2 в lf сделано =} потому что это синтаксически неверная подстрока на всех их базисных языках.
и это верный ход.

так что может лучше - научить сублиме закрывать такие скобки, т.е. {= ... =}
но лучше вместо = выбрать что-то другое мб, т.к. странно:
object x={=....=}
хотя бы
object x={__ .... __}
но посмотрим. вообще. приживется ли эта тема.
----
оказалось [[[ не подходит ]]] т.к. наш парсер считает что это начало 3д массива
что в принципе возможно. плохо.
но переставил приоритеты - заработало.

немного монстрообразно выглядит:

button "Удалить" 
  on_click=(m-lambda [[[
    (obj) => { console.log('removing',obj); obj.removedManually = true; obj.remove(); }
  ]]] @co->input?)

