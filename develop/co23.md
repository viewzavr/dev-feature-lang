# Пакет нововведений декабрь 2022

F-CO23 F-JS-INLINE

# Императивное вычисление

## Мотивация

Предыдущий вариант с m-lambda приводит к громоздким конструкциям, т.к. аргументы перечисляются и в сигнатуре js-кода, и по сути дублируются в позиционных аргументах. Дополнительно, Необходимость каждый раз писать `()=>{}` приводит к их постоянному присутствию, избыточности скобочек.

Пример:
```
button "Удалить" 
  on_click=(m-func "(obj) => {
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  }" @co->input?)
```

Нововведения (идея Михаил Бахетерев) по вычислениям в этом документе дают следующий, более лаконичный код:
```
button "Удалить" 
  on_click={: obj=@co->input? |
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  :}
```

## Новая форма вычислений

Форма `{: привязки-и-позиционые-аргументы | js-код :}` порождает функцию с привязками к контексту компаланга. Затем эту функцию можно вызывать из яваскрипта или с помощью eval.

Формат привязки: `a b=@some c=(compalang-expression) d=555 e f`.
Здесь `a,e,f` значит позиционые аргументы функции, а `b,c,d` - значения привязанные к окружению и константы.
Теперь все эти имена `a,b,c,d,e,f` можно использовать в js-кодеы.

Примеры:
```
let a = 5 b = 7
let f = {: a=@a q=(@a + @b) p=44 k | return [a+q+p,k] } // определили функцию с 1 позиционным аргументом (k)

console-log "result = " (m-eval @f) // вызов без передачи аргументов, k=undefined
console-log "result = " (m-eval @f 10) // вызов с передачей позиционных аргументов, k=10

console-log "simple result =" (m-eval {: 5+10 :}) // простое вычисление без привязок и без return
console-log "xtra result=" (m-eval {: f=@f | f.call( this, 10 ) }) // передача функции как аргумента и её вызов из js
```

# Реакции

Необходимо реагировать на события. Реакция это у нас формально - некое развитие процесса. Она может быть описана декларативно (на компаланге) или императивно. При этом декларативность, формально, может означать как дополнение процесса некоторыми подпроцессами, так и некоторое процессное вычисление, которое в конце концов заканчивается и сворачивается. Кроме того, у нас не поддерживается пока переход в "управляющие состояния", но возможно это и не надо, а возможно выражается декларативно/императивно, а возможно это можно поддержать в будущем.

Ранее у нас уже сделан ряд "обычных" реакций (on, c-on, cc-on) и реакций в режиме "массовых модификаторов": `@objlist | x-modify { x-on "func" }`. Их стало очень много, и надо сделать что-то одно. `on` - работали с событиями объектов вьюзавр. c-on и cc-on работали с каналами. В принципе, cc-on это почти то что надо, и мы его здесь зафиксируем с новым именем `reaction`.

Для массовых реакций - пока неясно что делать.

# reaction

1. Базовая форма
```
reaction @channel @func
```
- вызывает func при каждой записи в channel. Передает аргумент - значение, которое записали в channel.

Пример:

```
d: div
reaction (dom-event @d "mousemove") {: evt | console.log( evt.clientX) :}
```


2. Поддержка {}-функций
```
reaction @channel { |value|
	...compalang-code...
}
```
создается процесс, описанный compalang-code. Он завершается, когда в коде сработает оператор `return @some-value`.
(но в целом это все пока неясно очень все). По сути, это адаптер к make-func.

3. Поддержка input
```
@channel | reaction @func
@channel | reaction { |val|
  console-log "hello" @val | return
}
...
```
В этом варианте reaction.. может возвращать что-то полезное, например исходный канал.

Примечание: поддержку нескольких каналов в стиле `reaction @channels-list @func` решено пока не делать. Вместо неё race-channels @list и т.п.

## Получение каналов
Для работы реакций нужны каналы. В синтаксисе компаланг они недоступны. Предлагаются такие методы:
```
event @obj "name" -- возвращает канал, соответствующий событию name объекта @obj. Когда в объекте срабатывает событие, производится запись в канал. Если запись в канал производится извне, то в объекте срабатывает событие.
dom-event @obj "name" -- возвращает канал, соответствующий dom-событию name объекта @obj, который является dom-элементом.
param @obj "param-name" - возвращает канал, связанный с параметром param-name. Запись в канал производится, когда значение параметра присваивается (пусть даже). Запись в канал извне приводит к установке параметра.
method @obj "name" - запись в такой канал приводит к вызову метода (привязанной функции) у obj.
```
Соображения:
1. Здесь param реагирует на присвоение параметра. Возможно, стоит реагировать только на изменение, по выбору.

# Создание объектов
Текущая проблема компаланга в том что у него очень много методов создания объектов. Надо их сократить, до 1-2.
Потребности:
1. создать набор объектов согласно списку описаний объектов
Пример: ` read @objects-list | create target=@target-obj`
При этом надо уметь получить результат - список созданных объектов.
2. создать набор объектов согласно списку значений и описанию объекта.
Пример: ` repeater model=[1,2,3] { |input| rectangle width=@input } `
3. создать набор объектов согласно списку описаний объектов, и передать им значения в качестве позиционных аргументов:
Пример 1: `computing-env @arg1 @arg2 { |arg1 arg2| ...compalang... }`
Пример 2: `computing-env @arg1 @arg2 code=@some-code`
Если значения аргументов arg1 arg2 меняются, их следует передать в созданное окружение.
При этом, в случае конкретно computing-env, результатом является не список созданных объектов, а значение параметра output.
Вероятно, этот computing-env можно как-то было бы выразить через create (если бы тот умел передавать аргументы).

Примечания. Иногда в (1) требуется создавать объекты не в 1 целевом объекте @target-obj в наборе объектов. Но вероятно этого же можно достичь и используя repeater, т.е. `repeater { |target-obj| create input=@list target=@target-obj }`.

4. Создавать пустой объект 1 штуку. Это надо уметь, чтобы конструировать объекты с помощью компаланга динамически и описывать это на самом компаланге. Кроме этого, понадобится умение применять к объекту фичу, устанавливать параметры.
Это могло бы выглядеть так:
```
  let x = (create-object "button")
  let y = (create-object)
  apply-feature @y "buttons"
```
Также были мысли, что в качестве фичи может выступать и функция. Т.е. по сути это применение функции к объекту:
```
  apply-feature @obj (n-eval "|env| env.setParam('output',22) ")
```
В целом кстати последний вариант, с функцией, он честнее. Потому что фичи, похоже, это все-таки не часть объекта, не его "тип", а что-то отдельное, тоже кстати возможно объектное (если имеет параметры, которые могут меняться во времени). Но это история для отдельного размышления.

5. Создавать объекты не в пространстве детей, а в пространстве "внедренных-фич". Т.е. уметь динамически выполнять то, что у нас записывается сейчас как object {{ attached-feature @arg }}.

## Предложение
Выразить все потребности перечисленные выше с помощью методов `create` и `repeater`.

## create
create - создаёт набор объектов, передает им позиционные параметры. Примеры:
```
 create input=@objects-list target=@parent
 create input=@objects-list target=@parent @value1 @value2
 create target=@parent @value1 @value2 { |a1 a2|
 	... compalang-code ....
 }
```

## repeater
repeater - остается без изменений как уже есть сейчас. Репитер создает указанный объект N раз. N определяется массивом model, значения этого массива передаются через scope. Примеры:
```
 repeater model=@some-list code=@object-code
 repeater model=@some-list { |arg|
 	 console.log @arg
 }
```
Примечания. 
* Сейчас репитер на вход получает описание 1 объекта. Формально, он бы мог получать описание многих объектов - по идее, ему без разницы, при наличии scope, сколько объектов создавать в ответ на одну запись в model.
* Вероятно, репитер можно совместить с create, т.е. наделить create поведением репитера. Тогда:
```
  create model=@some-list code=@objects-list
```
создаст @objects-list объекты столько раз, сколько записей в some-list. Но это кажется является усложнением. Кроме того, они отлично компонуются, `repeater { create ... }`.

# Новейшая форма вычислений

Появилась идея (Михаил) такая что:
```
object a={: 5+5 :} // это функция
       b=({: 5+5 :}) // это вычисление
       c=({: a b | a+b :} 5 5) // вычисление с позиционными аргументами
       d=({: a | a+b :} 5 b=5) // вычисление с позиционными и именованными аргументами
```
Таким образом, с т.з. синтаксиса возникает следующая особая форма:
* ({: функциональное-выражение :} параметры...)
здесь скобки () обязательны, без них это выражение спутается с аргументами других объектов (т.к. стандартная форма в компаланг это `тип аргументы...`. Скобки () в компаланг означают "вычислить подвыражение" и поэтому это приемлемо и нормально.

Как индукция, видимо из этого следует такая возможность:
```
let foo={: a | a + b :}
foo b=4
```
то есть поиск "типов" объектов ("фич") проводится в scope. И если найденное значение есть "функция", то автоматически порождается объект типа eval. Можно ввести для определения функций и особую форму, чтобы было проще в реализации (генерить eval):
```
func foo {: a | a + b :}

//либо, как вариант, используя метки компаланга:
foo: func {: a | a + b :} // что-то мне не нравится что b не перечислена в привязках
```

Вопросы:
* о доступе изнутри js-кода к функциям, обозначенным в компланг-модуле:
```
func foo {: a | a + b :}
func foo2 {: a | a + foo(a,b) :}

foo2 5 10
```
Сейчас это получается нами никак не рассмотрено, и foo надо передавать явно. Но тут надо думать и думать много. В принципе, в принципе, можно сделать доступ ко всем функциям текущего scope. Другое дело, что мы тут вроде как начинаем переизобретать яваскрипт.. Но третье дело - таки мы делаем коды доступными по цепочке js -> компаланг, и наверное компаланг -> js тоже неплохо.

* о доступе к scope. Сейчас привязки к контексту прописываются явно, и это сделано намеренно.
	1. так удобнее реализовать отслеживание зависимостей. Отслеживать зависимости нам надо, т.к. компаланг реактивный. Поэтому если привязка поменялась, посылается сигнал - функция поменялась, и все её пользователи имеют возможность "пересчитаться".
	2. так удобнее программисту, он видит, с чем функция работает. Опыт qml показывает что рождаются функции на N экранов и середине у них доступ к контекстным переменным, и это неотслеживаемо никак.

Можно, как вариант, использовать вещи вида `$.name` (сейчас это уже есть в тестовом режиме - `scope.name`). Но надо очень осознанно к этому подойти...

* о значениях позиционных аргументов по умолчанию. Использовать синтаксис a=xxx как выше не получится, т.к. это означает просто привязку и такой аргумент пропускается:
```
func foo {: a b=12 : a + b :}
foo2 5 10 
```
Здесь 10 не пройдет, и будет 12 -- т.к. по логике в начале документа это привязка (binding) к окружению и такой параметр (b=..) не учтется в списке позиционных аргументов. Но можно попробовать хотя бы сделать так, чтобы eval переопределял значение именованного аргумента, и тогда получится сделать следующее:
```
foo2 5 b=10
```
Либо, надо пересмотреть правила, что есть привязки, и м.б. получится сделать так, чтобы переопределять значения привязанных к контексту аргументов и через передачу позиционных аргументов.

* о упрощенном порождении scope js -> компаланг. Думается что-то такое:
```
embed {: 
	// пошел яваскрипт.. и все имена объявленные тут видны компалангу...
	function foo() { ... }
	function foo2() { ... }
	function foo4() { ... }
:}

console-log (foo4 1 2 3)
```