Важно. Сv F_POSITIONAL_PARAMS как вариант замены этого всего.
Замысел такой теперь: 
```
x=(eval `(a,b) => a-b` @main->cx @main->r)
```
либо на будущее
```
x=(eval (interp `() => @main->cx - @main->r`))
x=(interp `@main->cx - @main->r`))
```
ну т.е. это как в js сделана интерполяция с кустомным языком. Но тут мы можем и позиционные аргументы кстати привлекать а не только инлайн упомянутые.

------

кстати идея - интерполяция строк...
тогда монстры типа
```
x=(compute_output cx=@main->cx r=@main->r code=`feature_env.params.cx - feature_env.params.r` | check_finite)
```
заменяется на
```
x=(compute_output code=`@main->cx - @main->r` | check_finite)
```

(я думал делать ${} но при наличии @ выглядит излишним. можно отказаться от @ но тогда вернуть {{ }})
и далее compute_output тоже можно заменить на что-то синтаксическое, например то же значение в начале строки `:
```
x=(`@main->cx - @main->r` | check_finite)
```
а вот это уже выглядит нелохо, но правда тогда
```
x=`@main->cx - @main->r`
```
придется тогда согласиться что строки ` это расчет.. хм..
ну или другой какой-то придумать что-то...
```
x=#{ 
  @main->cx - @main->r;
}
```
ну короче подумать. единственная тут засада это то что в QML было не фонтан - зависимости глубоко в кодах сидящие..
и я думал выдавать их отдельно из аргументов типа
```
x=(@main->cx as x, @main->r as r) => { return x+r };
```

но кстати это неплохо в том плане что похоже на js.. только без as а типа наверное так
```
x=(x: @main->cx, r: @main->r) => { return x+r };
```
хотя конечно
```
x=`@main->cx - @main->r` выглядит конечно покороче..
```

хм...

p.s. как вариант: js("код")
circle x=js("@main->cx - @main->r");
или если вспомнить что мы можем хотеть много разных интерпретаторов то аля
circle x=somelang( и тут что угодно... );

Это напоминает `` оператор в js (там тоже вроде можно подключать интерпретатор) но там есть какие-то проблемы
(вспомнить бы какие) которые мы можем избежать.. где же я это читал..

-----

Хорошо бы это сочесть еще с созданием тел функций. В том плане что мы не только выражение compute поставляем,
но и обработчики событий...
типа downmotion start=(event)=>{ js-код } finish=(event)=>{js код}

----------
// еще идеи:
// console_log text=_js_"FILTERED OBJECTS of pattern " + @root->pattern }}};
// console_log text=_in_"FILTERED OBJECTS of pattern @root->pattern";

-------------------------------------

F_SCOPE_ACCESS
Новая идея. В кодах скриптов допустить такое: scope.name и это будет доступ к скопу, т.е. наружу.
ну только надо понять, scope.name.get() или scope.name а если так то что делать с установкой? хотя можно оператор = тоже ловить...

Сделано... хм...