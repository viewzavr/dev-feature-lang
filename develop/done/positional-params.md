Позиционные параметры
=====================
F_POSITIONAL_PARAMS

До этого компаланг позволял ток именованные параметры у оббъектов: alfa beta=5 teta=7;
Но это оказалось неудобно для разных конструкций где как бы параметр 1 и ключ ему помнить это вынос мозга. Пример if:
```
if cond=.... {
}
```

Введены позиционные параметры. Т.о. если у объекта у параметра нет имени а сразу идет значение то он считается позиционным.
Это же распространяется и на вычисляющие параметры (). Таким образом стало возможно писать:
alfa 5 (sum 5 2)

Кроме того сделал что можно символы +-<>= добавлять в имя фичи и привет лисп.
И то что у нас имя фичи не обязательно первое позволяет делать конструкции 
вида (a1 < a2) где < это фича, а а1 a2 позиционные аргументы.

Итого теперь стало возможно писать:
```
if (@slider->value < (@sigma>level + 5)) {
}

```

Тонкости. Сейчас если код хочет работать с позиционными аргументами, то:
1. Параметр args_count и далее параметры с именем 0 1 2 3 и т.п.
2. Если это компаланг-объект, то он может делать так: text=@.->0? т.е. в text ставится ссылка из параметра 0 мягкая (символ ?) и это означает что undefined не копировать.
Таким образом можно при использовании юзать и text и позиционный вариант.

Также добавлен eval, который вызывает js код как лямбду и передает ей позиционные параметры:
```
eval code="(a,b) => a<b" @sigma->alfa @teta->beta;
```
У этой конструкции виден такой плюс, что явно вынесены все связи с внеш миром в сигнатуру, а не запрятаны в нутро кодов. Этим страдает qml а мы нет.

-----
Сделан тест [tests/positional-params](../../tests/positional-params)

-----
Ну и это вроде как заменяет нам интерполяцию, ну или может заменить.


------
TODO

Каррирование. Сейчас не реализовано. Получается мы не можем пока делать так:
```
alfa: beta 3 4;
beta: eval code=....
teta: alfa 7 7 7;
```
И это же ведет к тому что мы не можем делать и eval "code" arg1 arg2 arg3 потому что у нас eval нужна четкость, откуда брать код.
Хотя тут можно конечно что-то какой-то трюк придумать, что если нету code то иди на 0 аргумент. Но это не вариант, может быть код придет потом.
А вот если бы разораться с каррированием то он всегда будет в 0 параметре.

------
