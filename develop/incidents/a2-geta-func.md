Долго пытался сообразить почему не срабатывает m-eval в примере
```
let f = (import_js "some.js");
m_eval @f.somefunc 1 2 3;
```
оказалось что geta (а это операция .) сама собой вызывает функцию если видит ее.

Пришлось убрать.
это видимо нарушение принципа внедрения адаптера. а именно, это конечно адаптер, но вот он не в 100% оказался нужен.
т.о. это простая вредная удобняшка.

Но конечно было удобно писать @some.thing и при этом thing это функция без аргументов в объекте some (хоть js хоть vz).
Надо подумать, может удобно и вернуть будет или как-то оформлять особо.
В целом мы видим пока разговор о работе оператора ()..

-----
оказалось что я довольно часто этим пользуюсь.
и оказалось что еще я так вызываю "команды" объектов
мысли
- вернул если ставить eval=true то пусть вычисляет
- может ввести в имя вещи типа geta "flat()" и типа это вызов? но хотя это просто другая форма подачи параметра eval.
