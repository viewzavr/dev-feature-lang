# Императивное вычисление

F-JS-INLINE

В работе программ оказалось существуют потребности:

1. Описывать реакцию на то или иное событие. Вообще реакции на события -- это оказалось на практике есть основная часть программирования процессов. Даже если присмотреться к viewzavr - основной код любых объектов это `env.trackParam(name, reaction_code )`. Так что Хоар пока прав.
2. Описывать преобразование данных.

На практике оказалось, что наиболее удобно решать эти задачи с помощью js. Js все-таки пока выразительнее и мощнее, чем компаланг, и имеет доступ ко множеству API (nodejs, браузера). Компалангу же пока остается роль "коммуникационного языка" - описывать связи между объектами (которые выражаются, как я пока увидел, через налаживание маршрутизации `сообщений` и связь через `систему параметров`).

Я рассчитывал, что компаланг заменит js по части решения этих задач. В будущем возможно это так и будет. Речь даже не об императивности, а об организации вычисления, которое завершается некоторым конкретным результатом. Пока только робкие попытки сделать это на компаланг -- см. [reaction](reaction.md) и [make-func.js](../../libs/misc/make-func.js).

## Мотивация

Ранее реализована вещь m-lambda которая формирует функцию и ее привязки к контексту компаланг. Пример, вызов `m-lambda "js-code" arg1 arg2` возвращает (в поле output) функцию, которая является результатом выполнения `js-code`, и в эту функцию при вызове будут передавать аргументы arg1 и arg2. Также m-lambda пригодна и для каррирования, т.е. `m-lambda (m-lambda .... ) arg3`.

Вариант с m-lambda - работает, но приводит к громоздким конструкциям, т.к. аргументы перечисляются и в сигнатуре js-кода, и по сути дублируются в позиционных аргументах. Дополнительно, Необходимость каждый раз писать `()=>{}` приводит к их постоянному присутствию, избыточности скобочек.

Пример:
```
button "Удалить" 
  on_click=(m-func "(obj) => {
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  }" @co->input?)
```

Нововведения (идея Михаил Бахетерев) по вычислениям в этом документе дают следующий, более лаконичный код:
```
button "Удалить" 
  on_click={: obj=@co->input? |
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  :}
```

## Новая форма вычислений

Форма `{: привязки-и-позиционые-аргументы | js-код :}` порождает функцию с привязками к контексту компаланга. Затем эту функцию можно вызывать из яваскрипта или с помощью eval.

Формат привязки:
1. Привязка к контексту необязательна: `{: js-код :}`
2. В привязке через пробел перечисляются связи с контекстом и константы, т.е. записи вида `имя-для-js=выражение-компаланг`. Пример: `{: a=@alfa b=@beta c=(@some + @other) d=555 | ... :}`.
3. В привязке также перечисляются позиционные аргументы, т.е. записи вида `имя-для-js`. Пример: `{: a b c | ... :}`.
4. Связи и позиционные аргументы можно перемешивать: `a b=@some c=(compalang-expression) d=555 e f`. Здесь `a,e,f` позиционые аргументы функции, а `b,c,d` - значения привязанные к контексту.

Формат js-кода: 
1. Это обычный js код, который теперь может использовать имена, указанные в привязках.
2. Для возврата значения следует использовать `return`. В случае если в коде нет слова return, компаланг вставляет его автоматически как результат всего выражения.

Примеры:
```
let a = 5 b = 7
let f = {: a=@a q=(@a + @b) p=44 k | return [a+q+p,k] } // определили функцию с 1 позиционным аргументом (k)

console-log "result = " (m-eval @f) // вызов без передачи аргументов, k=undefined
console-log "result = " (m-eval @f 10) // вызов с передачей позиционных аргументов, k=10

console-log "simple result =" (m-eval {: 5+10 :}) // простое вычисление без привязок и без return
console-log "xtra result=" (m-eval {: f=@f | f.call( this, 10 ) }) // передача функции как аргумента и её вызов из js
console-log "simple sinus =" (m-eval {: Math.sin(it) :}) 3.14 // вычисление с автоматическим аргументом it
```

Идеи:
* По аналогии с Kotlin автоматически внедрять аргумент it как первый аргумент. Чтобы сократить запись кодов простых случаев (которых большинство)

# Новейшая форма вычислений

Появилась идея (Михаил) такая что:
```
object a={: 5+5 :} // это функция
       b=({: 5+5 :}) // это вычисление
       c=({: a b | a+b :} 5 5) // вычисление с позиционными аргументами
       d=({: a | a+b :} 5 b=5) // вычисление с позиционными и именованными аргументами
```
Таким образом, с т.з. синтаксиса возникает следующая особая форма:
* ({: функциональное-выражение :} параметры...)
здесь скобки () обязательны, без них это выражение спутается с аргументами других объектов (т.к. стандартная форма в компаланг это `тип аргументы...`. Скобки () в компаланг означают "вычислить подвыражение" и поэтому это приемлемо и нормально.

## Следствие

Как индукция, видимо из этого следует такая возможность:
```
let foo={: a | a + b :}
foo b=4
```
то есть поиск "типов" объектов ("фич") проводится в scope. И если найденное значение есть "функция", то автоматически порождается объект типа eval. Можно ввести для определения функций и особую форму, чтобы было проще в реализации (генерить eval):
```
func foo {: a | a + b :}

//либо, как вариант, используя метки компаланга:
foo: func {: a | a + b :} // что-то мне не нравится что b не перечислена в привязках
```

## Быстрое следствие
Мы можем пробовать применить уже сейчас -- если в выражении `foo args..` foo есть функция (найденная в scope), то порождать в этом месте eval. И даже форму func создать можем быстро. 

Таким образом, по существу, мы создадим новый формат описания "объектов". Это упрощенные объекты, получается. Они 

* описываются js-кодом
* реагируют на любой свой параметр (кроме output), 
* результат этой реакции - вычисление формулы - записывается в output. 

С учетом, что мы хотим двигать компаланг как замену js, это выглядит вполне возможным.

```
func text2arr {: str |
      return str.split(/[\s,]+/).map( parseFloat )
:} // определили

load-file "alfa.txt" | text2arr  // применили
```


# Вопросы:

## О доступе изнутри js-кода к функциям, обозначенным в компланг-модуле
```
func foo {: a | a + b :}
func foo2 {: a | a + foo(a,b) :}

foo2 5 10
```
Сейчас это получается нами никак не рассмотрено, и foo надо передавать явно. Но тут надо думать и думать много. В принципе, в принципе, можно сделать доступ ко всем функциям текущего scope. Другое дело, что мы тут вроде как начинаем переизобретать яваскрипт.. Но третье дело - таки мы делаем коды доступными по цепочке js -> компаланг, и наверное компаланг -> js тоже неплохо.

## О доступе к scope
Сейчас привязки к контексту прописываются явно, и это сделано намеренно:

1. так удобнее реализовать отслеживание зависимостей. Отслеживать зависимости нам надо, т.к. компаланг реактивный. Поэтому если привязка поменялась, посылается сигнал о том что функция поменялась, и все её пользователи имеют возможность "пересчитаться".
2. так удобнее программисту, он видит, с чем функция работает. Опыт qml показывает, что рождаются функции на N экранов и середине у них доступ к контекстным переменным, и это неотслеживаемо никак.

Можно, как вариант, использовать вещи вида `$.name` (сейчас это уже есть в тестовом режиме - `scope.name`). Но надо очень осознанно к этому подойти...

## Об значениях позиционных аргументов по умолчанию
Указать значения по умолчанию для позиционных аргументов, используя синтаксис `a=xxx`как выше -- не получится, т.к. `a=xxx` означает просто привязку и такой аргумент пропускается при подсчете позиционных аргументов:
```
func foo {: a b=12 | a + b :}
foo2 5 10 
```
Здесь 10 не пройдет, и будет 12 -- т.к. по логике в начале документа это привязка (binding) к окружению и такой параметр (b=..) не учтется в списке позиционных аргументов. Но можно попробовать хотя бы сделать так, чтобы eval переопределял значение именованного аргумента, и тогда получится сделать следующее:
```
foo2 5 b=10
```
Либо, надо пересмотреть правила, что есть привязки. И м.б. получится сделать так, чтобы переопределять значения привязанных к контексту аргументов и через передачу позиционных аргументов. То есть `eval {: a=5 b | console.log(a) :} 10 20` напечатало бы 10.

## Об упрощенном наполнении компаланг значениями из js scope

Думается что-то такое:
```
embed {: 
	// пошел яваскрипт.. и все имена объявленные тут видны компалангу...
	function foo() { ... }
	function foo2() { ... }
	function foo4() { ... }
:}

console-log (foo4 1 2 3)
```

Другое дело что из этого мы можем использовать. Ну, наверное функции. В том числе в новейшей нотации (как в примере -- `foo4 1 2 3`). Переменные - только на момент чтения, их изменения не отследить.

## Другая форма eval

мб сделать так:
```
console-log {: a=@alfa b=@beta | a > b :} // это eval
reaction @btn.click &{: event | console.log("privet",event.time) :} // это функция, на это указывает & перед блоком.
```

Вообще с такими скобками это сложно разглядеть. Мб вернуться к варианту с [[[[]]]:
```
console-log [[[ a=@alfa b=@beta | a > b ]]] // это eval
reaction @btn.click &[[[ event | console.log("privet",event.time) ]]] // это функция, на это указывает & перед блоком.
```
и тогда в принципе мы можем порождать лямбду во время eval:
```
reaction @btn.click [[[ (event) => console.log("privet",event.time) ]]]
```

Сравним еще раз:
```
if (eval {: a=@alfa b=@beta | a > b :}) { ... } // текущий вариант

if {: a=@alfa b=@beta | a > b :} { ... } // предлагается вот так - {: значит вычисление а не формула :}
if ({: a=@alfa b=@beta | a > b :}) { ... } // вариант с авто-eval функции, если она идет первой в выражении
if [[[ a=@alfa b=@beta | a > b ]]] { ... } // вариант с заменой скобки
```

```
reaction @btn.click {: event | console.log("privet",event.time) :} // текущий вариант

reaction @btn.click &{: event | console.log("privet",event.time) :} // вариант с & как указанием что это формула
reaction @btn.click =>{: event | console.log("privet",event.time) :} // вариант с => типа этот символ повиднее
reaction @btn.click &[[[ event | console.log("privet",event.time) ]]] // вариант с & и заменой скобки
```

Но в целом это выглядит странно все. Оставим пока как есть `(eval {:...:})`, посмотрим что получится.