# Вопрос конвейера визуализации

Есть данные и есть их загрузчик, он выдает некую структуру P.
Например:
dat: load_binary_file file=... | parse_vtk_points;

Вопрос как эту структуру данных P (= @dat->output) визуализировать.
Варианты:
1
@dat | render_vtk_points;

Здесь по существу render_vtk_points это есть points, оснащенные обработкой input
так что он может принимать на вход эту структуру. То есть мы по сути points
научили читать особый input. Так сделано например при визуализации data-frame-ов:
@dat | linestrips; // это работает потому-что linestrips научены читать такой input.

2
Но по уму, наверное схема должна быть такой что преобразование происходит как-то явно..
@dat -> convertor -> linestrips

и тогда:
- либо convertor выдает некую универсальную структуру данных, что вообще-то может быть
и дорого..
- либо convertor имеет доступ к целевому визуальному объекту и управляет им через его апи.
Но при этом он не создает этот визуальный объект как в случае с render-vtk-points
а получает его как бы на вход.

Вопрос - как тут правильно быть.

Схему два можно реализовать по-особому.

Итого рабочие варианты
@dat | df_points;
@dat | points points_df_input;
@dat | df_to_points | points;

сейчас же сделано
@dat | points; и это красиво, но что делать если меняется структура данных?
можно также туда интеллект посадить - и это будет эквивалентно примерно такому:
@dat | auto-select-convertor | points;

-----
Комментарий Михаила Бахтерева:
 должна быть 100% детерминированная конструкция, а пронюхивание - это генерация такой 100% цепочки для частного случая
Чтобы красиво читалось:
@dat | points from-df

Кстати, from-df может щупать текущее окружение? И видеть, что его просят сделать точки?
Тогда можно во from-df копить библиотеку преобразований в разные форматы, в зависимости от контекста. 
И будет относительно универсально
Итого варианты мы пока принимаем такие:
V1 с дефолтной структурой 
@dat | points; // здесь points читает некую оговоренную структуру в input, поставщики должны такую поставлять
V2 со специфичной 
@dat | raw-points using-some-specific-format; // здесь добавлен миксин using-some-specific-format который реагирует
на изменение input.

Вариант @dat | df_to_points | points; -- отвергнут по причине, что тут слишком небанальная реализация
Здесь по факту df_to_points - управляет окружением points через апи. И для реализации именно через |
ему придется передать указатель на функцию управления points. Это неочевидно.
Ибо на самом деле это 
@dat | df_to_points target=@somepts; 
somepts: points;
что выглядит длинной записью.
