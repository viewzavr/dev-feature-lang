# D-PARAM-EXISTm 09-2022
Оказалось важным различать между собой значение параметров и когда параметр не задан.
Долгое время значение undefined использовалось как признак что параметр не задан, не вычислен еще.
Практика показала что это надо отличать, бывают undefiend значения полноценные,
которые надо смело учитывать и передавать по назначению.

Лишь частным случаем возможно их отсекать, например в onvalue или m-eval это выглядит законным,
но частным решением. Т.е. это не на уровне системы решение (пропускать undefined и ждать определенности), и это правильно.
А не на уровне модели системы и работы ссылок в частности.

# Обязательный тип у записи

раньше можно было так
alfa=5
теперь обязательно укзаывать объект
object alfa=5

причины:
1 без этого невозможно будет отказаться от ;
2 встречал ошибку что неверно записал окружение, effect3d-opacity=5 и долго думал в чем проблема. если бы требовался тип было бы ясно причина.

см также F-WARN-A5

# Отказ от пайпов вида "@varname | item1 | item2"
по причине также что невозможно будет отказаться от ;
заменяем на
read @varname | item1 | item2.

но вообще это пока оставлено старое поведение для списков окружений где такой пайп первый. потому что их более 200.

# F-LET-ASSIGN-NOW
let присваивает значения в скоуп сразу же, даже если еще не рассчитаны.
если этого не сделать то ссылки его переменные отваливаются со временем по таймауту
т.к. у них свои варнинги что ссылаемся на неизвестный параметр.

# F-NO-COMMA
2022-10-06 Убрано требование ; теперь можно без нее (т.е. она необяз разделитель сейчас).
Таким образом мы привели все к 2 формам:
тип арг арг
либо
арг тип арг. (для ограниченного кол-ва типов выписанных в парсере)
посмотрим что из этого выйдет.

# F-ORDER-22-11
update убрано, вроде как неестественно и ненужно. а нужно думать в других направлениях. главное чтобы json рассчитывался.
Сделан экспериментально такой порядок инициализации, чтобы ()-выражения что-нибудь возвращали, а потом уже инициализировался основное тулово.
Но на практике это приводит к тому что они там честно зависают внутри (), и получается что основной объект не инициализируется.
Пока сделал что на оператор or это логика отклюичается, и можно писать: alfa beta=(0 or (..зависающий процесс..))
Таким образом у нас тут подобие императивной подготовки данных. когда вычисляются аргументы а потом управление передается в целевой объект.

# F-PARALLEL-CHILDREN
update пока убрано
В связи с F-ORDER-22-11 стало зависать создание процессов, следующих за ожидаемым. Поэтому разрешено в createChildrenByDump не ждать завершения
создания узла полностью а переходить к следующему.
update F-ORDER-22-11 отменено, но для эксперимента оставлено параллельное создание детей. вроде норм - порядок то у них создается какой надо.

# F-PARAMS-STREAM
Экспериментально сделано 2 вида ссылок - 1) передают сигнал только по changed
2) передают сигнал по присваиванию.
Для варианта (2) указывается спец-символ ! в конце имени. Итого: object alfa=@beta! teta=@sigma
Дополнительно сделано что
а) пайпа использует такие ссылки всюду у себя - автоматом.
б) ()-выражения тоже так сделаны - автоматом.

# F-COMMENTS
Добавлен однострочный комментарий вида #, допом к //
Причина - частое использование в других языках.