# Создание объектов
Текущая проблема компаланга в том что у него очень много методов создания объектов. Надо их сократить, до 1-2.

Потребности:
1. создать набор объектов согласно списку описаний объектов
Пример: ` read @objects-list | create target=@target-obj`
При этом надо уметь получить результат - список созданных объектов.
2. создать набор объектов согласно списку значений и описанию объекта.
Пример: ` repeater model=[1,2,3] { |input| rectangle width=@input } `
3. создать набор объектов согласно списку описаний объектов, и передать им значения в качестве позиционных аргументов:
Пример 1: `computing-env @arg1 @arg2 { |arg1 arg2| ...compalang... }`
Пример 2: `computing-env @arg1 @arg2 code=@some-code`
Если значения аргументов arg1 arg2 меняются, их следует передать в созданное окружение.
При этом, в случае конкретно computing-env, результатом является не список созданных объектов, а значение параметра output.
Вероятно, этот computing-env можно как-то было бы выразить через create (если бы тот умел передавать аргументы).

Примечания. Иногда в (1) требуется создавать объекты не в 1 целевом объекте @target-obj в наборе объектов. Но вероятно этого же можно достичь и используя repeater, т.е. `repeater { |target-obj| create input=@list target=@target-obj }`.

4. Создавать пустой объект 1 штуку. Это надо уметь, чтобы конструировать объекты с помощью компаланга динамически и описывать это на самом компаланге. Кроме этого, понадобится умение применять к объекту фичу, устанавливать параметры.
Это могло бы выглядеть так:
```
  let x = (create-object "button")
  let y = (create-object)
  apply-feature @y "buttons"
```
Также были мысли, что в качестве фичи может выступать и функция. Т.е. по сути это применение функции к объекту:
```
  apply-feature @obj (n-eval "|env| env.setParam('output',22) ")
```
В целом кстати последний вариант, с функцией, он честнее. Потому что фичи, похоже, это все-таки не часть объекта, не его "тип", а что-то отдельное, тоже кстати возможно объектное (если имеет параметры, которые могут меняться во времени). Но это история для отдельного размышления.

5. Создавать объекты не в пространстве детей, а в пространстве "внедренных-фич". Т.е. уметь динамически выполнять то, что у нас записывается сейчас как object {{ attached-feature @arg }}.

## Предложение
Выразить все потребности перечисленные выше с помощью методов `create` и `repeater`.

## create
create - создаёт набор объектов, передает им позиционные параметры. Примеры:
```
 create input=@objects-list target=@parent
 create input=@objects-list target=@parent @value1 @value2
 create target=@parent @value1 @value2 { |a1 a2|
 	... compalang-code ....
 }
```

## repeater
repeater - остается без изменений как уже есть сейчас. Репитер создает указанный объект N раз. N определяется массивом model, значения этого массива передаются через scope. Примеры:
```
 repeater model=@some-list code=@object-code
 repeater model=@some-list { |arg|
 	 console.log @arg
 }
```
Примечания. 
* Сейчас репитер на вход получает описание 1 объекта. Формально, он бы мог получать описание многих объектов - по идее, ему без разницы, при наличии scope, сколько объектов создавать в ответ на одну запись в model.
* Вероятно, репитер можно совместить с create, т.е. наделить create поведением репитера. Тогда:
```
  create model=@some-list code=@objects-list
```
создаст @objects-list объекты столько раз, сколько записей в some-list. Но это кажется является усложнением. Кроме того, они отлично компонуются, `repeater { create ... }`.