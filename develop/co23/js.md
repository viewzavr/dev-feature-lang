# Императивное вычисление

F-JS-INLINE

Императивное вычисление все-таки оказалось необходимо в компаланг. Оно возникает в случаях:

1. Когда надо описать реакцию на то или иное событие. Вообще реакции на события это оказалось на практике основная часть описания процессов. Даже если присмотреться к viewzavr - основной код любых объектов это `env.trackParam(name, reaction_code )`.
2. Когда надо описать преобразование данных. Js все-таки пока выразительнее и мощнее, чем компаланг, и имеет доступ ко множеству API (nodejs, браузера).

При этом на js описываются также и базовые фичи компаланг, но этого оказалось недостаточно, а оказалось удобно внедрять js в компаланг коды (раз других методов не нашлось для решения задач 1 и 2). В целом я рассчитывал, что компаланг заменит js, в том числе по части императивности, но пока этого не произошло. Точнее речь не об императивности, а об организации вычисления, которое завершается некоторым конкретным результатом. Пока только робкие попытки сделать это на компаланг -- см. reaction и make-func. 

## Мотивация

Ранее реализована вещь m-lambda которая формирует функцию и ее привязки к контексту компаланг. Пример, вызов `m-lambda "js-code" arg1 arg2` возвращает (в поле output) функцию, которая является результатом выполнения `js-code`, и в эту функцию при вызове будут передавать аргументы arg1 и arg2. Также m-lambda пригодна и для каррирования, т.е. `m-lambda (m-lambda .... ) arg3`.

Вариант с m-lambda - работает, но приводит к громоздким конструкциям, т.к. аргументы перечисляются и в сигнатуре js-кода, и по сути дублируются в позиционных аргументах. Дополнительно, Необходимость каждый раз писать `()=>{}` приводит к их постоянному присутствию, избыточности скобочек.

Пример:
```
button "Удалить" 
  on_click=(m-func "(obj) => {
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  }" @co->input?)
```

Нововведения (идея Михаил Бахетерев) по вычислениям в этом документе дают следующий, более лаконичный код:
```
button "Удалить" 
  on_click={: obj=@co->input? |
     console.log('removing',obj); obj.removedManually = true; obj.remove(); 
  :}
```

## Новая форма вычислений

Форма `{: привязки-и-позиционые-аргументы | js-код :}` порождает функцию с привязками к контексту компаланга. Затем эту функцию можно вызывать из яваскрипта или с помощью eval.

Формат привязки:
1. Привязка к контексту необязательна: `{: js-код :}`
2. В привязке через пробел перечисляются связи с контекстом и константы, т.е. записи вида `имя-для-js=выражение-компаланг`. Пример: `{: a=@alfa b=@beta c=(@some + @other) d=555 | ... :}`.
3. В привязке также перечисляются позиционные аргументы, т.е. записи вида `имя-для-js`. Пример: `{: a b c | ... :}`.
4. Связи и позиционные аргументы можно перемешивать: `a b=@some c=(compalang-expression) d=555 e f`. Здесь `a,e,f` позиционые аргументы функции, а `b,c,d` - значения привязанные к контексту.

Формат js-кода: 
1. Это обычный js код, который теперь может использовать имена, указанные в привязках.
2. Для возврата значения следует использовать `return`. В случае если в коде нет слова return, компаланг вставляет его автоматически как результат всего выражения.

Примеры:
```
let a = 5 b = 7
let f = {: a=@a q=(@a + @b) p=44 k | return [a+q+p,k] } // определили функцию с 1 позиционным аргументом (k)

console-log "result = " (m-eval @f) // вызов без передачи аргументов, k=undefined
console-log "result = " (m-eval @f 10) // вызов с передачей позиционных аргументов, k=10

console-log "simple result =" (m-eval {: 5+10 :}) // простое вычисление без привязок и без return
console-log "xtra result=" (m-eval {: f=@f | f.call( this, 10 ) }) // передача функции как аргумента и её вызов из js
console-log "simple sinus =" (m-eval {: Math.sin(it) :}) 3.14 // вычисление с автоматическим аргументом it
```

Идеи:
* По аналогии с Kotlin автоматически внедрять аргумент it как первый аргумент. Чтобы сократить запись кодов простых случаев (которых большинство)

# Новейшая форма вычислений

Появилась идея (Михаил) такая что:
```
object a={: 5+5 :} // это функция
       b=({: 5+5 :}) // это вычисление
       c=({: a b | a+b :} 5 5) // вычисление с позиционными аргументами
       d=({: a | a+b :} 5 b=5) // вычисление с позиционными и именованными аргументами
```
Таким образом, с т.з. синтаксиса возникает следующая особая форма:
* ({: функциональное-выражение :} параметры...)
здесь скобки () обязательны, без них это выражение спутается с аргументами других объектов (т.к. стандартная форма в компаланг это `тип аргументы...`. Скобки () в компаланг означают "вычислить подвыражение" и поэтому это приемлемо и нормально.

Как индукция, видимо из этого следует такая возможность:
```
let foo={: a | a + b :}
foo b=4
```
то есть поиск "типов" объектов ("фич") проводится в scope. И если найденное значение есть "функция", то автоматически порождается объект типа eval. Можно ввести для определения функций и особую форму, чтобы было проще в реализации (генерить eval):
```
func foo {: a | a + b :}

//либо, как вариант, используя метки компаланга:
foo: func {: a | a + b :} // что-то мне не нравится что b не перечислена в привязках
```

# Вопросы:

## О доступе изнутри js-кода к функциям, обозначенным в компланг-модуле
```
func foo {: a | a + b :}
func foo2 {: a | a + foo(a,b) :}

foo2 5 10
```
Сейчас это получается нами никак не рассмотрено, и foo надо передавать явно. Но тут надо думать и думать много. В принципе, в принципе, можно сделать доступ ко всем функциям текущего scope. Другое дело, что мы тут вроде как начинаем переизобретать яваскрипт.. Но третье дело - таки мы делаем коды доступными по цепочке js -> компаланг, и наверное компаланг -> js тоже неплохо.

## О доступе к scope
Сейчас привязки к контексту прописываются явно, и это сделано намеренно:

1. так удобнее реализовать отслеживание зависимостей. Отслеживать зависимости нам надо, т.к. компаланг реактивный. Поэтому если привязка поменялась, посылается сигнал о том что функция поменялась, и все её пользователи имеют возможность "пересчитаться".
2. так удобнее программисту, он видит, с чем функция работает. Опыт qml показывает, что рождаются функции на N экранов и середине у них доступ к контекстным переменным, и это неотслеживаемо никак.

Можно, как вариант, использовать вещи вида `$.name` (сейчас это уже есть в тестовом режиме - `scope.name`). Но надо очень осознанно к этому подойти...

## Об значениях позиционных аргументов по умолчанию
Указать значения по умолчанию для позиционных аргументов, используя синтаксис `a=xxx`как выше -- не получится, т.к. `a=xxx` означает просто привязку и такой аргумент пропускается при подсчете позиционных аргументов:
```
func foo {: a b=12 | a + b :}
foo2 5 10 
```
Здесь 10 не пройдет, и будет 12 -- т.к. по логике в начале документа это привязка (binding) к окружению и такой параметр (b=..) не учтется в списке позиционных аргументов. Но можно попробовать хотя бы сделать так, чтобы eval переопределял значение именованного аргумента, и тогда получится сделать следующее:
```
foo2 5 b=10
```
Либо, надо пересмотреть правила, что есть привязки. И м.б. получится сделать так, чтобы переопределять значения привязанных к контексту аргументов и через передачу позиционных аргументов. То есть `eval {: a=5 b | console.log(a) :} 10 20` напечатало бы 10.

## Об упрощенном наполнении компаланг значениями из js scope

Думается что-то такое:
```
embed {: 
	// пошел яваскрипт.. и все имена объявленные тут видны компалангу...
	function foo() { ... }
	function foo2() { ... }
	function foo4() { ... }
:}

console-log (foo4 1 2 3)
```

Другое дело что из этого мы можем использовать. Ну, наверное функции. В том числе в новейшей нотации (как в примере -- `foo4 1 2 3`). Переменные - только на момент чтения, их изменения не отследить.