# Виды создания объектов

Сейчас на уровне синтаксиса языка предусмотрено несколько режимов создания объектов. Надо понять все ли из них нужны.

## Простой

```
objtype a=5 b=7;
```

будет создан новый объект (="окружение", процесс), присвоены значения параметров a и b, и вызвана фича objtype на этом объекте.
Фича это получилось функция, которая на вход получает объект, а на выходе ничего не выдает, но вносит модификации в объект.

В данном случае фича аналогична функции конструктора в ооп. Правда она не имеет параметров кроме самого объекта, но она может
читать его параметры (в данном примере a и b) или присваивать их.


## Составной

```
objtype alfa a=5 b=7 beta;
```
будет создан новый объект, и будет вызвано 3 функции фич - objtype, alfa и beta.

Откуда это взялось - год назад я решил попробовать, что пусть объекты стоятся как бы не из типов, а из mixin-ов.
От этого и название языка даже. Мол мы соединяем в одном объекте несколько фич.
Почему-то тогда мне это показалось будет эффективно.

Что оказалось по факту использования.
1. Когда несколько фич, удобно искать объекты по меткам "классов" как в CSS. Делается пустая фича, навешивается на объект,
и далее мы легко все нужные объекты по таким фичам находим.
Пример:
```
  someobj myflag;
  otherobj myflag;
  
  find-objects-bf "myflag" | console-log;
  // вернет массив из 2х объектов
```
2. Внедрение функционала через перечисление нескольких фич оказалось почему-то не очень востребовано, не очень нужно.
Иногда применяется, но не часто.

Чаще такой функционал применяется из js-кода фич. Например, загрузка дополнительных возможностей АПИ системы в объекты 
(связывание с объектами), например delayed.

## Host-модификаторы

Основная причина мб почему составные фичи не прижились оказалось то, что фичам все-таки нужны свои параметры.
При этом использовать параметры объекта они не могут, т.к. начинаются пересечения по именам.
Поэтому введен следующий синтаксис:
```
objtype a=5 b=7 {{ somebehaviour teta=5 b=8; otherfeature a="privet" }}
```
Здесь создается 3 окружения. Одно обычное objtype и два необычных somebehaviour и otherfeature. Эти два последних
1. При создании на них сохраняется ссылки из основного объекта (attached features).
При удалении основного объекта они также удаляются.
2. В их объекты вводится ссылка на основной объект, поле .host.

Таким образом код этих фич может понимать, что объект находится в режиме прикрепления к хосту, и может как-то им управлять.
При этом пространства параметров различны - у субфичи свои, у хоста свои.

В принципе, оказалось что подход вполне себе рабочий. Но часто место {{ .. }} используется просто для размещения каких-то рабочих объектов,
которые почему-то не хочется добавлять в список children основного объекта.

## X-модификаторы

Оказалось что host-модификаторы не всегда справляются с задачей модификации. Например пусть надо внедрить некое поведение в большое число объектов
или даже во все объекты в памяти. Если делать это как предлагают host-модификаторы т.е. путем создания host-объектов для целевого окружнеия
то это получается очень дорого (на каждый целевой объект - создается объект модификатора).
```
find-objects-bf "viewzavr-object" // нашли все объекты
|
insert-features {
  some-modifier t=5;
};
```

Поэтому был применен механизм модификаторов из Kotlin Compose. Этот механизм говорит что модификатор может быть один на много объектов,
и он узнает об этих объектах когда ему присылают сообщение по подписке или отписке.
Получилось так:

```
find-objects-bf "viewzavr-object" // нашли все объекты
|
x-modify {
  some-modifier t=5;
};
```
здесь x-modify следит за своим входным массивом input, понимает какие у него новые элементы и какие старые. При появлении новых высылает 
сообщение attach(obj) объекту some-modifier, а при исчезновении старых посылает detach(obj). Схема показала свою большую эффективность -
действительно, выполнять императивный js-код для каждого объекта, возможно создавая при этом окружения js для внедрения в них поведения,
вполне дешево.

# Итоги
Получается что у нас есть 4 подхода по влиянию на объект. Первые 3 из них поддержаны синтаксически, 4-й работает на базе основного синтаксиса.
Хотелось бы понять что тут является лишним.

# p.s. Проект отмены точки с запятой.
Есть мысль что можно отказаться от точки с запятой в языке. Ее наличие множество раз приводило к тому иногда я забывал ее указывать 
и несколько объектов слеплялись в один и подобный баг очень долго выискивается.
Например забудем указать точку с запятой и все пропарсится и станет работать, но не пойми как:
```
points positions=... 
spheres positions=...
```

Мы могли бы автоматически понимать, когда кончается один объект и начинается другой.
Но наличие нескольких фич в записи объекта - `someobj other feat` - видимо и лишает возможности отказаться от точки с запятой.
Действительно, если бы фича была бы одна, и она всегда была бы первой - то тогда можно было бы отсекать объекты, встречая новый символ фичи.

Сейчас надо так указывать 2 объекта:
```
  points positions=... ;
  spheres positions=...
```
Могло бы быть:
```
  points positions=... 
  spheres positions=...
```

Но с другой стороны - сейчас фича не обязана быть записана в начале текста объекта. Это позволяет делать трюк с арифметическими операциями. Сейчас можно писать:
```
  if ((@a + @b) > 5) then={....}
```
здесь символы "+" и ">" это имена фич.

Если же требовать что фича первая, то придется перейти на лисп-стиль для арифм операций, а нехотелось бы - это непривычно.
С другой стороны может быть для таких операций можно предусмотреть особые формы.

# p.p.s.
Переговорили с Михаилом Бахтеревым пришли к выводу что да вариант без ; лучше т.к. выглядит регулярнее. Он требует что первая запись это имя фичи и в этом регулярность.
Но выяснилось что этот подход отменяет пайп-синтаксис в случае когда первая запись есть ссылка.
```
some-operator
@alfa | operation ...
```
решили что здесь нужно разделитель, и т.о. необходимо будет делать так:
```
some-operator
read @alfa | operation ...
```
В тестовой версии проекта таких случаев порядка 300. Поэтому решено:
1. Пока оставить все как есть по вопросу ;. Вместо этого добавлены warning-и когда первым идет не фича.
2. Внедрить для теста оператор read и посмотреть что будет получаться.

----
По вопросу модификаторов - Михаил предложил оставить только x-modify, как наиболее универсальный. Единственное меня смущает то что на практике оказалось очень удобным
делать вещи вида 
```
obj {{ modifs ... }} a=5 b=7 {{ modifs... }} c=5 { ... }
```
но надо начинать смотреть в сторону только x-modify.