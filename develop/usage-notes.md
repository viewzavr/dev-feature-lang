coview - state для реакций быбы. было б проще.
param @root.tasks
coview вот бы удобно было менять на цилиндры отрезки!
вот хотя опять же - копите DF-ку. А ее рисуйте стандартными средствАми
coview rgb=%{: [1,5,10/2] :}
----

* onvalue - это changed? или любое?
* как сделать чтобы onvalue вызвалось повторно?
* разобраться с cmd @x "name", event @x "name", reaction @x.name
это все крышесносно. надо единообразно. в идеале - вообще один канал.

какие-то мысли про накидывание гуи.. что типа вот это соберем сюда и будет у нас гуи..
типа галочками отмечаем что набрать в каком порядке..
а это ведет к списку путей объектов и их параметров..

*****
=>
по компалангу генеральный план это
- особые формы уметь добавлять на уровне языка
- пакеты
- вот всякие доработки из usage-notes.txt

мб создать diary.md?

****
как получить канал по имени созданному через let?
let x = ....
канал x ?

****
как сделать что если есть входное значение - то проверить его и пропустить согласно проверке дальше?
вот банально а тем не менее..

... | pass-if .... | ..
-----
вообще получается у нас как-то с абстрагированием тяжко. вот я пытаюсь сделать такую вещь - внедрить преобразование значения
на основе некоего внешнего состояния (которое еще и надо менять). и как?
... | fix_time t0=&t0 | ...

----
мысль - удобно ввести shortcut для m-eval типа такого: [: ... | ... :]
я вооще хотел сразу чтоб {: ... :} вычислялась. но она уже занята. поэтому времянка [::]
а потом сделаем {: ... :} это вычисление жс а &{: ... :} это функция.

мысль - удобно сделать таки доступ к scope из этих кодов. но при этом - доступ к scope не вызывает отслеживания пусть.
ну так удобно например. ну то есть что попалось то и хорошо. а если надо отслеживание - переносим в параметры.
F-FUNC-ACCESS-SCOPE

****
3 вида файлов в категории Данные это явный перебор.
----
как-то напрашивается cv-вещи делать автоматически из компаланг-вещей..
мб функцией которая совмещает с регистрацией..
-****
x-patch-r2 какая-то мутная тема. равно как и все модификаторы вообще.
нельзя было сделать что ли просто обработку input да и все?
ну и типа там массив - применяем ко всем. там одна - применяем к одной.
ну а в хост-окружениях {{ }} выставляем input автоматом всем у кого его нету.
или переменную host заводим и прописываем... зачем я так все усложнил то..

реально - модификаторы переусложнены. надо их сделать существенно проще.

----
выяснилось что в компаланг нет формул в смысле angular signals (computed) (аналогичное было и в qml).
И выяснилось что эти формулы это нечто отдельное, явная отдельная сущность. И идет ассоциация - ячейка-формула.
А в КО все делается через тн. эффекты. Впрочем та же история и в Лингва-Франка - сплошная пуш-модель.
Не знаю хорошо это или плохо. Но плохо то что у меня
- неясная мешанина параметры-ячейки
- нет таки возможности устанавливать в ячейку функцию расчета ее значения (что было бы гибкость добавило..)
- нет удобства доступа к ячейкам (reaction &x ...)
- главное - путаница с детерменированностью, что кого куда после чего. это выносит мозг.
----

как плагин добавит категорию в гуи для добавляемых объектов? правильно - никак.
были мысли - надо как-то ввести работу с классами, что ли.. аля html


*******************
            text_sprite_one 
              text=(m-eval {: t=@record.0 | return t.substring(0,20) :})
              text=@{: t=@record.0 | return t.substring(0,20) :}
              text=@{: t=@record.0 | t.substring(0,20) :}
              text=(@record.0 | substring 0 20)
              text=(@record.0 | ijs "substring" 0 20)
              text=@{: return this._.record[0].substring(0,20) :}
              text=(@record.0 | js.substring 0 20)
              text=(@record.0 | m-eval "substring" 0 20)
              text=(@record.0.substring 0 20)
?
**************              